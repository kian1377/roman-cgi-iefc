import numpy as np
import cupy as cp
import poppy
if poppy.accel_math._USE_CUPY:
    from cupyx.scipy.sparse import linalg as sLA
else:
    from scipy.sparse import linalg as sLA

from scipy import interpolate, ndimage
import time
from astropy.io import fits
from matplotlib.patches import Circle, Rectangle
import pickle

import matplotlib.pyplot as plt

from cgi_phasec_poppy import misc

def map_acts_to_dm(actuators, dm_mask, Nact=48):
    inds = np.where(dm_mask.flatten().astype(int))[0]
    
    command = np.zeros((Nact, Nact))
    command.ravel()[inds] = actuators
    
    return command

# Create control matrix
def WeightedLeastSquares(A, W, rcond=1e-15):
    # W is the weight matrix
    cov = A.T.dot(W.dot(A))
    return np.linalg.inv(cov + rcond * np.diag(cov).max() * np.eye(A.shape[1])).dot( A.T.dot(W) )

def TikhonovInverse(A, rcond=1e-15):
    if isinstance(A, cp.ndarray):
        U, s, Vt = cp.linalg.svd(A, full_matrices=False)
    else:
        U, s, Vt = np.linalg.svd(A, full_matrices=False)
    s_inv = s/(s**2 + (rcond * s.max())**2)
    return (Vt.T * s_inv).dot(U.T)

def beta_reg(S, beta=-1):
    # S is the sensitivity matrix, also known as the Jacobian
    sts = np.matmul(S.conj().T, S)
    rho = np.diag(sts)
    alpha2 = rho.max()
    
    gain_matrix = np.matmul( np.linalg.inv( sts + alpha2*10.0**(beta)*np.eye(sts.shape[0]) ), S.T)
    return gain_matrix


def create_circ_mask(h, w, center=None, radius=None):

    if center is None: # use the middle of the image
        center = (int(w//2), int(h//2))
    if radius is None: # use the smallest distance between the center and image walls
        radius = min(center[0], center[1], w-center[0], h-center[1])
        
    Y, X = np.ogrid[:h, :w]
    dist_from_center = np.sqrt((X - center[0] + 1/2)**2 + (Y - center[1] + 1/2)**2)

    mask = dist_from_center <= radius
    return mask

# Creating focal plane masks
def create_annular_focal_plane_mask(x, y, params):
    inner_radius, outer_radius, edge_position, rot = (params['inner_radius'], params['outer_radius'], 
                                                      params['edge_position'], params['rotation'])
    
    r = np.hypot(x, y)
    mask = (r < outer_radius) * (r > inner_radius)
    if params['full']==False:
        mask *= (x > edge_position)
    else:
        mask *= (abs(x) > edge_position)
    
    mask = ndimage.rotate(mask, rot, reshape=False, order=0)
    
    return mask

def create_box_focal_plane_mask(x, y, params):
    x0, y0, width, height = (params['x0'], params['y0'], params['w'], params['h'])
    mask = ( abs(x - x0) < width/2 ) * ( abs(y - y0) < height/2 )
    return mask > 0


def create_bowtie_mask(x, y, params):
    inner_radius, outer_radius, side = (params['inner_radius'], params['outer_radius'], params['side'])
    
    r = np.hypot(x, y)
    th = np.arctan2(x,y)*180/np.pi + 180
    
    mask = (r < outer_radius) * (r > inner_radius)
    
    if side=='left' or side=='l':
        mask *= (th>57.5) * (th<57.5+65)
    elif side=='right' or side=='r':
        mask *= (th<(360-57.5)) * (th>(360-57.5-65))
    if side=='both' or side=='b':
        mask *= (th>57.5) * (th<57.5+65) + (th<(360-57.5)) * (th>(360-57.5-65))
    
    return mask
    
    
    
def sms(U, s, alpha2, electric_field, N_DH, Imax_unocc, itr): 
    # jac: system jacobian
    # electric_field: the electric field acquired by estimation or from the model
    
    E_ri = U.conj().T.dot(electric_field)
    SMS = np.abs(E_ri)**2/(N_DH/2*Imax_unocc)

    Nbox = 31
    box = np.ones(Nbox)/Nbox
    SMS_smooth = np.convolve(SMS, box, mode='same')
    
    x = s**2/alpha2
    y = SMS_smooth
    
    xmax = np.max(x)
    xmin = 1e-10 
    ymax = 1
    ymin = 1e-14
    
    fig = plt.figure(dpi=125)
    plt.loglog(x, y)
    plt.title('Singular Mode Spectrum: Iteration {:d}'.format(itr))
    plt.xlim(xmin, xmax)
    plt.ylim(ymin, ymax)
    plt.xlabel(r'$(s_{i}/\alpha)^2$: Square of Normalized Singular Values')
    plt.ylabel('SMS')
    plt.grid()
    plt.close()
    display(fig)
    
    return fig
    

def masked_rms(image,mask=None):
    return np.sqrt(np.mean(image[mask]**2))

def get_random_probes(rms, alpha, dm_mask, fmin=1, fmax=17, nprobe=3):
    # randomized probes generated by PSD
    shape = dm_mask.shape
    ndm = shape[0]

    allprobes = []
    for n in range(nprobe):
        fx = np.fft.rfftfreq(ndm, d=1.0/ndm)
        fy = np.fft.fftfreq(ndm, d=1.0/ndm)
        fxx, fyy = np.meshgrid(fx, fy)
        fr = np.sqrt(fxx**2 + fyy**2)
        spectrum = ( fr**(alpha/2.0) ).astype(complex)
        spectrum[fr <= fmin] = 0
        spectrum[fr >= fmax] = 0
        cvals = np.random.standard_normal(spectrum.shape) + 1j * np.random.standard_normal(spectrum.shape)
        spectrum *= cvals
        probe = np.fft.irfft2(spectrum)
        probe *= dm_mask * rms / masked_rms(probe, dm_mask)
        allprobes.append(probe.real)
    if nprobe==2:
        misc.myimshow2(allprobes[0], allprobes[1])
    elif nprobe==3:
        misc.myimshow3(allprobes[0], allprobes[1], allprobes[2])
    return np.asarray(allprobes)

from scipy.linalg import hadamard
def get_hadamard_modes_1(dm_mask): 
    Nacts = dm_mask.sum().astype(int)
    np2 = 2**int(np.ceil(np.log2(Nacts)))
    hmodes = hadamard(np2)
    
    had_modes = []

    inds = np.where(dm_mask.flatten().astype(int))
    for hmode in hmodes:
        hmode = hmode[:Nacts]
        mode = np.zeros((dm_mask.shape[0]**2))
        mode[inds] = hmode
        had_modes.append(mode)
    had_modes = np.array(had_modes)
    
    return had_modes

def get_hadamard_modes_2(Nacts, dm_mask): 
    np2 = 2**int(np.ceil(np.log2(Nacts)))
    hmodes = hadamard(np2)
    print(hmodes.shape)
    
    had_modes_1 = []
    had_modes_2 = []
    
    Nact = int(dm_mask.sum())

    inds = np.where(dm_mask.flatten().astype(int))
    for hmode in hmodes:
        hmode_1 = hmode[:Nact]
        hmode_2 = hmode[Nacts//2:Nact]
        mode_1 = np.zeros((dm_mask.shape[0]**2))
        mode_1[inds] = hmode_1
        mode_2 = np.zeros((dm_mask.shape[0]**2))
        mode_2[inds] = hmode_2
        had_modes_1.append(mode_1)
        had_modes_2.append(mode_2)
    had_modes_1 = np.array(had_modes_1)
    had_modes_2 = np.array(had_modes_2)
    
    return had_modes_1, had_modes_2

def create_fourier_modes(xfp, mask, Nact=34, use_both=True, circular_mask=True):
    print("Creating Fourier modes: ", mask.shape)
    intp = interpolate.interp2d(xfp, xfp, mask)
    
    # This creates the grid and frequencies
    xs = np.linspace(-0.5, 0.5, Nact) * (Nact-1)
#     print(xs)
    x, y = np.meshgrid(xs, xs)
    x = x.ravel()
    y = y.ravel()
    
    # Create the fourier frequencies. An odd number of modes is preferred for symmetry reasons.
    if Nact % 2 == 0: 
        fxs = np.fft.fftshift( np.fft.fftfreq(Nact+1) )
    else:
        fxs = np.fft.fftshift( np.fft.fftfreq(Nact) )
        
    fx, fy = np.meshgrid(fxs, fxs)
#     print(fx)
    # Select all Fourier modes of interest based on the dark hole mask and remove the piston mode
    mask2 = intp(fxs * Nact, fxs * Nact) * (((fx!=0) + (fy!=0)) > 0) > 0
#     print(mask2.shape)
#     misc.myimshow(mask2)

    fx = fx.ravel()[mask2.ravel()]
    fy = fy.ravel()[mask2.ravel()]
#     print(fx)
    # The modes can rewritten to a single (np.outer(x, fx) + np.outer(y, fy))
    if use_both:
        M1 = [np.cos(2 * np.pi * (fi[0] * x + fi[1] * y)) for fi in zip(fx, fy)]
        M2 = [np.sin(2 * np.pi * (fi[0] * x + fi[1] * y)) for fi in zip(fx, fy)]
        
        # Normalize the modes
        M = np.array(M1+M2)
    else:
        M = np.array([np.sin(2 * np.pi * (fi[0] * x + fi[1] * y)) for fi in zip(fx, fy)])
        
    if circular_mask: 
        circ = np.ones((Nact,Nact))
        r = np.sqrt(x.reshape((Nact,Nact))**2 + y.reshape((Nact,Nact))**2)
        circ[r>(Nact)/2] = 0
        M[:] *= circ.flatten()
        
    M /= np.std(M, axis=1, keepdims=True)
        
    return M, fx, fy

def select_fourier_modes(sysi, control_mask, fourier_sampling=0.75):
    xfp = (np.linspace(-sysi.npsf/2, sysi.npsf/2-1, sysi.npsf) + 1/2) * sysi.psf_pixelscale_lamD
    fpx, fpy = np.meshgrid(xfp,xfp)
#     print(xfp)
    
    intp = interpolate.interp2d(xfp, xfp, control_mask) # setup the interpolation function
    
    xpp = np.linspace(-sysi.Nact/2, sysi.Nact/2-1, sysi.Nact) + 1/2
    ppx, ppy = np.meshgrid(xpp,xpp)
#     print(xpp)
    
    fourier_lim = fourier_sampling * np.round(xfp.max()/fourier_sampling)
    xfourier = np.arange(-fourier_lim-fourier_sampling/2, fourier_lim+fourier_sampling, fourier_sampling)
    fourier_x, fourier_y = np.meshgrid(xfourier, xfourier) 
#     print(xfourier)
    
    # Select the x,y frequencies for the Fourier modes to calibrate the dark hole region
    fourier_grid_mask = ( (intp(xfourier, xfourier) * (((fourier_x!=0) + (fourier_y!=0)) > 0)) > 0 )
#     misc.myimshow(fourier_grid_mask)
    
    fxs = fourier_x.ravel()[fourier_grid_mask.ravel()]
    fys = fourier_y.ravel()[fourier_grid_mask.ravel()]
    sampled_fs = np.vstack((fxs, fys)).T
#     print(sampled_fs.shape)
    
    cos_modes = []
    sin_modes = []
    for f in sampled_fs:
        fx = f[0]/sysi.Nact
        fy = f[1]/sysi.Nact
        cos_modes.append( ( np.cos(2 * np.pi * (fx * ppx + fy * ppy)) * sysi.dm_mask ).flatten() ) 
        sin_modes.append( ( np.sin(2 * np.pi * (fx * ppx + fy * ppy)) * sysi.dm_mask ).flatten() )
    modes = cos_modes + sin_modes
    return np.array(modes), sampled_fs

def fourier_mode(lambdaD_yx, rms=1, acts_per_D_yx=(48,48), Nact=48, phase=0):
    '''
    Allow linear combinations of sin/cos to rotate through the complex space
    * phase = 0 -> pure cos
    * phase = np.pi/4 -> sqrt(2) [cos + sin]
    * phase = np.pi/2 -> pure sin
    etc.
    '''
    idy, idx = np.indices((Nact, Nact)) - (34-1)/2.
    
    #cfactor = np.cos(phase)
    #sfactor = np.sin(phase)
    prefactor = rms * np.sqrt(2)
    arg = 2*np.pi*(lambdaD_yx[0]/acts_per_D_yx[0]*idy + lambdaD_yx[1]/acts_per_D_yx[1]*idx)
    
    return prefactor * np.cos(arg + phase)

def create_fourier_probes(fourier_modes, Nact=48, display_probes=False): 
    # make 2 probe modes from the sum of the cos and sin fourier modes
    nfs = fourier_modes.shape[0]//2
    probe1 = fourier_modes[:nfs].sum(axis=0).reshape(Nact,Nact)
    probe2 = fourier_modes[nfs:].sum(axis=0).reshape(Nact,Nact)

    probe1 /= probe1.max()
    probe2 /= probe2.max()

    probe_modes = np.array([probe1,probe2])
    probe_modes.shape
    
    if display_probes:
        misc.myimshow2(probe1, probe2)

        oversample = 4
        probe1_fft = np.fft.fftshift(np.fft.fft2(misc.pad_or_crop(probe1, Nact*oversample)))
        probe2_fft = np.fft.fftshift(np.fft.fft2(misc.pad_or_crop(probe2, Nact*oversample)))

        misc.myimshow2(np.abs(probe1_fft), np.abs(probe2_fft), 
                       pxscl1=1/oversample, pxscl2=1/oversample)
    
    return probe_modes

def create_probe_poke_modes(Nact, 
                            xinds,
                            yinds,
                            display=False):
    probe_modes = np.zeros((len(xinds), Nact, Nact))
    for i in range(len(xinds)):
        probe_modes[i, yinds[i], xinds[i]] = 1
    
    if display:
        if len(xinds)==2:
            misc.myimshow2(probe_modes[0], probe_modes[1])
        elif len(xinds)==3:
            misc.myimshow3(probe_modes[0], probe_modes[1], probe_modes[2])
            
    return probe_modes
